# 回流和重绘

## 浏览器的渲染过程

先看来自MDN的渲染过程图：

![title](http://upload-images.jianshu.io/upload_images/16323523-11f8f0d37fd2d592.png)

从这张图我们可以简单的分析出浏览器的渲染过程分为以下几个步骤：
1. 解析HTML，形成DOM树
2. 解析CSS，形成CSSOM，
3. 将DOM树和CSSOM树结合生成渲染树（Render Tree）
4. 根据生成的渲染树，进行回流，计算节点的位置和大小（回流/Layout）
5. 根据渲染树和回流得到的几何信息，得到节点的绝对元素（重绘/Painting）
6. 将元素发送到GPU，展示再页面上（展示/Display）

生产的渲染树如下所示：

![title](https://camo.githubusercontent.com/4f6b3a439d409d75a6baea662b623e0ac5ac8e34/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31322f31302f313637393862386438333961376436643f773d3131353026683d35333726663d706e6726733d3334393434)

### 重绘
当元素样式改变不影响元素在文档流中位置（如：color、background-color、visibility、border-color等元素），浏览器只会将新样式赋予元素并触发重绘

### 回流
渲染树中部分或全部元素因为尺寸、布局、隐藏等相应到元素的布局时会触发回流，主要有以下几个几种情况：

* 添加或删除**可见的元素**
* 元素的位置发生变化
* 元素的尺寸发生变化（包括border,margin,padding,width,height）
* 元素内容发生变化
* 浏览器的窗口尺寸发生变化（滚动或缩放）
* 激活伪类元素（:hover等）

回流时，浏览器会使的渲染树中受影响的部分失效，然后重新渲染这部分的render树，完成回流后会重新绘制布局，绘制受影响的部分，这就是重绘。
每个页面至少需要一次回流，就是页面第一次加载时。回流变化涉及到部分页面（或整个页面）的布局。一个元素的回流导致其所有子元素以及DOM中紧随其后的祖先元素和其子元素都发生回流。

:::danger
回流一定会引起重绘，执行顺序是先回流后重绘
:::

### 减少重绘和节流

* 添加css样式而不是用js去控制样式
* 尽量在DOM的最末端改变class
* 将需要多次回流的元素设置为position:fixed或者position:absolute
* 尽量不要用table布局
* 一个元素如果需要用js才操作dom，尽量将需要改变的dom批量操作完。

### 浏览器优化机制
回流的开销很大，如果每个操作都去重绘和回流的话，浏览器会受不了，浏览器会将要回流和重绘的操作放在一个队列里，浏览器会去维护这个队列，当队列中的操作达到一定的数量或者到达了一定的时间，浏览器就会flush这个队列，进行一个批处理，这样就能够减少重绘和回流的次数。

虽然有了浏览器的优化，但有时一些代码可能会强制浏览器提前flush队列，这样浏览器的优化可能就起不到作用了。当请求向浏览器请求一些 style信息的时候，就会让浏览器flush队列，比如：

* offsetTop, offsetLeft, offsetWidth, offsetHeight
* scrollTop/Left/Width/Height
* clientTop/Left/Width/Height
* width,height
* 请求了getComputedStyle(), 或者 IE的 currentStyle
所以要减少对这些元素的使用，如果要多次用到这个值，可以在第一次的时候定义一个变量，然后缓存起来。




