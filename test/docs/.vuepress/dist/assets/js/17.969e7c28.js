(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{204:function(a,t,e){"use strict";e.r(t);var r=e(0),s=Object(r.a)({},function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h3",{attrs:{id:"js内存空间"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js内存空间","aria-hidden":"true"}},[a._v("#")]),a._v(" JS内存空间")]),a._v(" "),e("h4",{attrs:{id:"数据结构类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据结构类型","aria-hidden":"true"}},[a._v("#")]),a._v(" 数据结构类型")]),a._v(" "),e("p",[a._v("计算机中有以下三种数据结构：")]),a._v(" "),e("ul",[e("li",[a._v("栈（特点：先进后出，典型例子：执行上下文栈）")]),a._v(" "),e("li",[a._v("队列（先进先出，理解队列对于理解事件循环有很大的帮助）")]),a._v(" "),e("li",[a._v("堆（好比在JSON格式的数据中，我们存储的key-value是可以无序的）。变量对象存在与堆内存中。")])]),a._v(" "),e("h4",{attrs:{id:"变量对象和基本数据类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#变量对象和基本数据类型","aria-hidden":"true"}},[a._v("#")]),a._v(" 变量对象和基本数据类型")]),a._v(" "),e("p",[a._v("之前介绍过在javascript的执行过程中，会创建一个执行上下文，在执行上下文创建完后，会创建一个变量对象的特殊变量（当代码执行时变量对象变成了活动对象）。基本数据类型就保存在变量对象中。基础数据类型都是按值访问，因为我们可以直接操作保存在变量中的实际的值。")]),a._v(" "),e("h4",{attrs:{id:"引用数据类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#引用数据类型","aria-hidden":"true"}},[a._v("#")]),a._v(" 引用数据类型")]),a._v(" "),e("p",[a._v("JS的引用数据类型是保存在堆内存中的对象。js不允许直接访问堆内存中的数据。因此引用数据类型是按值传递的。在操作对象时，实际上是在操作对象的引用而不是实际的对象。\n通过下面一些例子来了解变量对象和堆内存")]),a._v(" "),e("p",[e("code",[a._v("var a1 = 0; // 变量对象 var a2 = 'this is string'; // 变量对象 var a3 = null; // 变量对象 var b = { m: 20 }; // 变量b存在于变量对象中，{m: 20} 作为对象存在于堆内存中 var c = [1, 2, 3]; // 变量c存在于变量对象中，[1, 2, 3] 作为对象存在于堆内存中")]),a._v(" "),e("img",{attrs:{src:"https://leanote.com/api/file/getImage?fileId=5ce2b90dab644149370072cb",alt:"title"}}),a._v("\n因此当我们要访问堆内存中的引用数据类型时，实际上我们首先是从变量对象中获取了该对象的地址引用。\n虽然我们知道了这个知识点，但是在实际过程中，可能还是会忽略，一下这个列子是我最近放的一个错误。\nlet obj = {name: 'liaozhen', age: 25}\nlet arr = [{name: '小王', age: 24}, {name: '小明', age: 23}]")])])},[],!1,null,null,null);t.default=s.exports}}]);